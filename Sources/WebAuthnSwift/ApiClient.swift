//
//  File.swift
//  
//
//  Created by Shu on 2022/03/06.
//

import Foundation
import Combine

let BASE_URL = "https://dev-api.credify.ninja"

@available(iOS 13.0, *)
struct BaseApiClient {
    private static let baseURL = URL(string: BASE_URL)!
    private static let AUTH_ERROR_LIMIT = 3
    private static var authErrorCount = 0
    
    private static var cancellables = Set<AnyCancellable>()
    
    static func execute<T: Codable>(request: URLRequest) -> Future<T, CustomError> {
        var body = ""
        if let json = try? JSONSerialization.jsonObject(with: request.httpBody ?? Data(), options: []) as? [String: Any] {
            body = json.json
        }
        
        print("\n\n ⚡️ ⚡️ ⚡️ REQUEST INFO ⚡️ ⚡️ ⚡️ \n ===[Info]: \n URL: \(request.url?.absoluteString ?? "") \n Method: \(request.httpMethod ?? "") \n Parameters:\(request.allHTTPHeaderFields?.json ?? "") \n Body: \(body)")
        
        return Future() { promise in
            URLSession.shared.dataTaskPublisher(for: request)
                .tryMap() { element -> Data in
                    guard let response = element.response as? HTTPURLResponse else {
                        throw CustomError.requestError(message: "Request error")
                    }
                    
                    let traceId = (response.allHeaderFields["x-trace-id"] as? String) ?? ""
                    
                    if let json = try? JSONSerialization.jsonObject(with: element.data, options: []) as? [String: Any] {
                        print("Response: \(json.json)")
                    }
                    
                    guard 200 ..< 300 ~= response.statusCode else {
                        throw CustomError.requestError(message: "\(response.statusCode) Error \n\n\(traceId)")
                    }
                    
                    return element.data
                }
                .decode(type: T.self, decoder: JSONDecoder())
                .mapError { error -> CustomError in
                    if error is DecodingError {
                        return CustomError.requestError(message: "Decode error")
                    } else {
                        return CustomError.requestError(message: error.localizedDescription)
                    }
                }
                .sink(receiveCompletion: { completion in
                    switch completion {
                    case .finished:
                        break
                    case .failure(let error):
                        promise(.failure(error))
                    }
                },
                      receiveValue: {
                    promise(.success($0))
                })
                .store(in: &self.cancellables)
        }
    }
}


/**
 API client that uses access token generated by an API key of an ecosystem
 
 NOTE: This is essentially same as `PublicApiClient`. Better to combine the code.
 */
@available(iOS 13.0, *)
struct ApiClient {
    static var accessToken: String = ""
    private static var cancellables = Set<AnyCancellable>()

    static func call<T: Codable>(apiRequest: ApiRequest) -> Future<T, CustomError> {
        let apiKey = WebAuthnSwift.apiKey
        return Future() { promise in
            if accessToken.isEmpty {
                BaseApiClient.execute(request: ClientAuthenticationRequest().convert(apiKey: apiKey))
                    .sink(receiveCompletion: { completion in
                        switch completion {
                        case .finished:
                            break
                        case .failure(let error):
                            print(error)
                            promise(.failure(.requestError(message: "API key is not correct")))
                        }
                    }, receiveValue: { (tokenRes: GetAccessTokenResponse) in
                        self.accessToken = tokenRes.data.accessToken
                        BaseApiClient.execute(request: apiRequest.convert(with: tokenRes.data.accessToken))
                            .sink(receiveCompletion: { completion in
                                switch completion {
                                case .finished:
                                    break
                                case .failure(let error):
                                    promise(.failure(error))
                                }
                            },
                                  receiveValue: {
                                promise(.success($0))
                            })
                            .store(in: &self.cancellables)
                    })
                    .store(in: &self.cancellables)
            } else {
                BaseApiClient.execute(request: apiRequest.convert(with: accessToken))
                    .sink(receiveCompletion: { completion in
                        switch completion {
                        case .finished:
                            break
                        case .failure(let error):
                            promise(.failure(error))
                        }
                    },
                          receiveValue: {
                        promise(.success($0))
                    })
                    .store(in: &self.cancellables)
            }
        }
    }
}
